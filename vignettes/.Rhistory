xlab("x")+
xlab(paste0("x", i, sep ="")))
}
plot(mean_std_errs,  (valid_df$GPmu -15) / sqrt((valid_df$GPuncert)))
abline(3,0)
library(hetGP)
library(reticulate)
library(lhs)
library(ggplot2)
library(rdist)
library(rstan)
library(dplyr)
#plot mean std errs
for (i in 1:(length(xv[1,])+1)){
print(ggplot()+
geom_point(aes(x= pull(valid_df, i), y=mean_std_errs))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
}
for (i in 1:(length(xv[1,])+1)){
print(ggplot()+
geom_point(aes(x= pull(valid_df, i), y=VarUs))+
geom_hline(yintercept = 0.95, color = "red")+
geom_hline(yintercept = -0.95, color = "red")+
geom_hline(yintercept = 0, color = "black")+
geom_hline(yintercept = -0.5, color = "grey")+
geom_hline(yintercept = 0.5, color = "grey")+
ylim(-1,1)+
xlim(0,1)+
ylab("Variance Unexpectedness")+
xlab(paste0("x", i, sep ="")))
}
sum(VarUs > 0)
59/80
load("~/My_Files/PhD/HMLSE/250_2 Good results/Validation/Emul_Validation_Wave1.RData")
#plot  std errs
for (i in 1:(length(xv[1,])+1)){
print(ggplot()+
geom_point(aes(x= cbind(xv,xqv)[,i], y=std_errs))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
}
plot(std_errs,  (as.numeric(hetGP_pred_v[1,]) - 15) / sqrt(as.numeric(hetGP_pred_v[2,])))
abline(3,0)
load("~/My_Files/PhD/HMLSE/250_2 Good results/Validation/Emul_Validation_Wave2.RData")
#plot  std errs
for (i in 1:(length(xv[1,])+1)){
print(ggplot()+
geom_point(aes(x= cbind(xv,xqv)[,i], y=std_errs))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
}
plot(std_errs,  (as.numeric(hetGP_pred_v[1,]) - 15) / sqrt(as.numeric(hetGP_pred_v[2,])))
abline(3,0)
load("~/My_Files/PhD/HMLSE/250_2 Good results/Validation/Emul_Validation_Wave3.RData")
#plot  std errs
for (i in 1:(length(xv[1,])+1)){
print(ggplot()+
geom_point(aes(x= cbind(xv,xqv)[,i], y=std_errs))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
}
load("~/My_Files/PhD/HMLSE/500_1 Good results/Validation/Emul_Validation_Wave1.RData")
#plot  std errs
for (i in 1:(length(xv[1,])+1)){
print(ggplot()+
geom_point(aes(x= cbind(xv,xqv)[,i], y=std_errs))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
}
plot(std_errs,  (as.numeric(hetGP_pred_v[1,]) - 15) / sqrt(as.numeric(hetGP_pred_v[2,])))
abline(3,0)
load("~/My_Files/PhD/HMLSE/500_1 Good results/Validation/Emul_Sto_Validation_Wave2.RData")
load("~/My_Files/PhD/HMLSE/500_1 Good results/Validation/Emul_Sto_Validation_Wave3.RData")
#plot mean std errs
for (i in 1:(length(xv[1,])+1)){
print(ggplot()+
geom_point(aes(x= pull(valid_df, i), y=mean_std_errs))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
}
plot(mean_std_errs,  (valid_df$GPmu -15) / sqrt((valid_df$GPuncert)))
abline(3,0)
for (i in 1:(length(xv[1,])+1)){
print(ggplot()+
geom_point(aes(x= pull(valid_df, i), y=VarUs))+
geom_hline(yintercept = 0.95, color = "red")+
geom_hline(yintercept = -0.95, color = "red")+
geom_hline(yintercept = 0, color = "black")+
geom_hline(yintercept = -0.5, color = "grey")+
geom_hline(yintercept = 0.5, color = "grey")+
ylim(-1,1)+
xlim(0,1)+
ylab("Variance Unexpectedness")+
xlab(paste0("x", i, sep ="")))
}
sum(VarUs>0)
load("~/My_Files/PhD/HMLSE/500_1 Good results/Validation/Emul_Validation_Wave3.RData")
#plot  std errs
for (i in 1:(length(xv[1,])+1)){
print(ggplot()+
geom_point(aes(x= cbind(xv,xqv)[,i], y=std_errs))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
}
plot(std_errs,  (as.numeric(hetGP_pred_v[1,]) - 15) / sqrt(as.numeric(hetGP_pred_v[2,])))
abline(3,0)
#plot  std errs
print(ggplot()+
geom_point(aes(x= seq(0,1, len = 400), y=rnorm(400, 0,1)))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
#plot  std errs
print(ggplot()+
geom_point(aes(x= seq(0,1, len = 400), y=rnorm(400, 0,1)))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
#plot  std errs
print(ggplot()+
geom_point(aes(x= seq(0,1, len = 400), y=rnorm(400, 0,1)))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
#plot  std errs
print(ggplot()+
geom_point(aes(x= seq(0,1, len = 400), y=rnorm(400, 0,1)))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
load("~/My_Files/PhD/HMLSE/250_2 Good results/Validation/Emul_Validation_Wave3.RData")
#plot  std errs
for (i in 1:(length(xv[1,])+1)){
print(ggplot()+
geom_point(aes(x= cbind(xv,xqv)[,i], y=std_errs))+
geom_hline(yintercept = 2, color = "red")+
geom_hline(yintercept = -2, color = "red")+
geom_hline(yintercept = 0, color = "black")+
xlab("x")+
xlab(paste0("x", i, sep ="")))
}
n_out <- 5 #how many PCs matter?
#So first lets load the required functions
source('~/My_Files/Covid/QK_functions.R')
library(ggplot2)
#and load in the data
data = read.csv("~/My_Files/Covid/wards_by_day_100.csv", header = TRUE)
#tidy up the data
data_frame <- as.matrix(data)
X <- data_frame[,2:6]
y <- data_frame[,7:ncol(data_frame)]
X_valid <- X[126:200,]
y_valid <- y[126:200,]
X <- X[1:125,]
y <- y[1:125,]
#high dimensional output is a pain, so we reduce it via PCA
y_pr <- prcomp(y, rank = 20)
summary(y_pr) #only first 2 matter
n_out <- 5 #how many PCs matter?
n_dropped = 15 #how many lost?
#get our "outputs"
y_out <- y_pr$x[,1:n_out]
#fit QK for these outputs
QK_emuls <- QK_emul_fit(X,y_out)
#and predict
X_pred <- randomLHS(100,5) * 2 -1
X_pred[,5] <-  0.5
X_pred[,1:3] <- 0.5
QKpred <- QK_emul_predict_samples(X_pred, QK_emuls, 100)
#convert to regular space
preds <- array(NA, c(nrow(QKpred[[1]]), nrow(X_pred), ncol(y)))
for (i in 1:nrow(QKpred[[1]])){
trans_pred = cbind(QKpred[[1]][i,], QKpred[[2]][i,], QKpred[[3]][i,], QKpred[[4]][i,], QKpred[[5]][i,], matrix(0, ncol = n_dropped, nrow = nrow(X_pred)) )
pred <- t(t(trans_pred %*% t(y_pr$rotation)) + y_pr$center)
preds[i,,] <- pred
print(i) #progress meter
}
ggplot()+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.5)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.6)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.4)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.25)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.75)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.025)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.975)))
#and then validation
QKpred <- QK_emul_predict_samples(X_valid, QK_emuls, 100)
#convert to regular space
preds <- array(NA, c(nrow(QKpred[[1]]), nrow(X_valid), ncol(y)))
for (i in 1:nrow(QKpred[[1]])){
trans_pred = cbind(QKpred[[1]][i,], QKpred[[2]][i,], QKpred[[3]][i,], QKpred[[4]][i,], QKpred[[5]][i,], matrix(0, ncol = n_dropped, nrow = nrow(X_valid)) )
pred <- t(t(trans_pred %*% t(y_pr$rotation)) + y_pr$center)
preds[i,,] <- pred
print(i) #progress meter
}
ggplot()+
geom_point(aes(x=X_valid[,1], y = apply(preds[,,20],2, quantile, 0.5)))+
geom_errorbar(aes(x=X_valid[,1], ymin = apply(preds[,,20],2, quantile, 0.025), ymax =apply(preds[,,20],2, quantile, 0.975)  ))+
geom_point(aes(x=X_valid[,1], y = y_valid[,20]), colour = "red")
#So first lets load the required functions
source('~/My_Files/Covid/QK_functions.R')
library(ggplot2)
library(lhs)
#and load in the data
data = read.csv("~/My_Files/Covid/wards_by_day_100.csv", header = TRUE)
#tidy up the data
data_frame <- as.matrix(data)
X <- data_frame[,2:6]
y <- data_frame[,7:ncol(data_frame)]
X_valid <- X[126:200,]
y_valid <- y[126:200,]
X <- X[1:125,]
y <- y[1:125,]
#high dimensional output is a pain, so we reduce it via PCA
y_pr <- prcomp(y, rank = 20)
summary(y_pr) #only first 2 matter
n_out <- 5 #how many PCs matter?
n_dropped = 15 #how many lost?
#get our "outputs"
y_out <- y_pr$x[,1:n_out]
#fit QK for these outputs
QK_emuls <- QK_emul_fit(X,y_out)
#and predict
X_pred <- randomLHS(100,5) * 2 -1
X_pred[,5] <-  0.5
X_pred[,1:3] <- 0.5
QKpred <- QK_emul_predict_samples(X_pred, QK_emuls, 100)
#convert to regular space
preds <- array(NA, c(nrow(QKpred[[1]]), nrow(X_pred), ncol(y)))
for (i in 1:nrow(QKpred[[1]])){
trans_pred = cbind(QKpred[[1]][i,], QKpred[[2]][i,], QKpred[[3]][i,], QKpred[[4]][i,], QKpred[[5]][i,], matrix(0, ncol = n_dropped, nrow = nrow(X_pred)) )
pred <- t(t(trans_pred %*% t(y_pr$rotation)) + y_pr$center)
preds[i,,] <- pred
}
ggplot()+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.5)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.6)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.4)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.25)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.75)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.025)))+
geom_line(aes(x=X_pred[,4], y = apply(preds[,,40],2, quantile, 0.975)))
#and then validation
QKpred <- QK_emul_predict_samples(X_valid, QK_emuls, 100)
#convert to regular space
preds <- array(NA, c(nrow(QKpred[[1]]), nrow(X_valid), ncol(y)))
for (i in 1:nrow(QKpred[[1]])){
trans_pred = cbind(QKpred[[1]][i,], QKpred[[2]][i,], QKpred[[3]][i,], QKpred[[4]][i,], QKpred[[5]][i,], matrix(0, ncol = n_dropped, nrow = nrow(X_valid)) )
pred <- t(t(trans_pred %*% t(y_pr$rotation)) + y_pr$center)
preds[i,,] <- pred
}
ggplot()+
geom_point(aes(x=X_valid[,1], y = apply(preds[,,20],2, quantile, 0.5)))+
geom_errorbar(aes(x=X_valid[,1], ymin = apply(preds[,,20],2, quantile, 0.025), ymax =apply(preds[,,20],2, quantile, 0.975)  ))+
geom_point(aes(x=X_valid[,1], y = y_valid[,20]), colour = "red")
#now convert data into quantiles
quantile_df <- data.frame(X = X, y = y) #create data frame
quantile_df <-  quantile_df %>% group_by_at(vars(names(quantile_df)[1:(length(X[1,]))])) %>% summarise("0.025" = quantile(y, 0.025), "0.25" = quantile(y, 0.25), "0.5" = quantile(y, 0.5), "0.75" = quantile(y, 0.75), "0.975" = quantile(y, 0.975))
quantile_df
quantile_df <- data.frame(X = X, y = y) #create data frame
quantile_df %>% group_by_at(vars(names(quantile_df)[1:(length(X[1,]))]))
quantile_df <- data.frame(X = X, y = y) #create data frame
quantile_df %>% group_by_at(vars(names(quantile_df)[1:(length(X[1,]))]))
quantile_df$y
quantile_df <-  quantile_df %>% group_by_at(vars(names(quantile_df)[1:(length(X[1,]))])) %>% summarise("0.025" = quantile(y, 0.025))
quantile_df$`0.025`
quantile_df <-  quantile_df %>% group_by_at(vars(names(quantile_df)[1:(length(X[1,]))]))
quantile_df
quantile_df %>% summarise("0.025" = quantile(y, 0.025))
quantile_df %>% summarise_each(funs (`0` = quantile(., 0, na.rm=T),
`25`= quantile(., .25, na.rm = T),
`75`= quantile(., .75, na.rm = T)))
quantile_df %>% summarise_each((`0` = quantile(., 0, na.rm=T),`25`= quantile(., .25, na.rm = T), `75`= quantile(., .75, na.rm = T)))
quantile_df %>% summarise_each(list(`0` = quantile(., 0, na.rm=T),`25`= quantile(., .25, na.rm = T), `75`= quantile(., .75, na.rm = T)))
quantile_df %>% summarise_each(list(~quantile(., 0, na.rm=T),~quantile(., .25, na.rm = T), ~quantile(., .75, na.rm = T)))
quantile_df %>% summarise_each(list("0.025" ~quantile(., 0.025, na.rm=T),"0.25"~quantile(., 0.25, na.rm = T), "0.5"~quantile(., 0.5, na.rm = T) , "0.75"~quantile(., 0.75, na.rm = T), "0.975"~quantile(., 0.975, na.rm = T) ))
quantile_df %>% summarise_each(list("0.025" ~quantile(., 0.025, na.rm=T),"0.25"~quantile(., 0.25, na.rm = T) ))
quantile_df %>% summarise_each(list(`0.025' ~quantile(., 0.025, na.rm=T),`0.25'~quantile(., 0.25, na.rm = T) ))
quantile_df %>% summarise_each(list(`0` = quantile(., 0, na.rm=T),`25`= quantile(., .25, na.rm = T), `75`= quantile(., .75, na.rm = T)))
quantile_df %>% summarise_each(list(`0` ~ quantile(., 0, na.rm=T),`25`~ quantile(., .25, na.rm = T), `75`~ quantile(., .75, na.rm = T)))
quantile_df %>% summarise_each(list(`0` ~quantile(., 0, na.rm=T),`25`~quantile(., .25, na.rm = T), `75`~quantile(., .75, na.rm = T)))
quantile_df %>% summarise_each(list(~quantile(., 0.025, na.rm=T),~quantile(., .25, na.rm = T), ~quantile(., .5, na.rm = T), ~quantile(., .75, na.rm = T), ~quantile(., .975, na.rm = T)))
quantile_df <- data.frame(X = X, y = y) #create data frame
quantile_df <-  quantile_df %>% group_by_at(vars(names(quantile_df)[1:(length(X[1,]))]))
quantile_df %>% summarise_each(list(~quantile(., 0.025, na.rm=T),~quantile(., .25, na.rm = T), ~quantile(., .5, na.rm = T), ~quantile(., .75, na.rm = T), ~quantile(., .975, na.rm = T)))
#This script does QK-PCA where the quantiles are calculated before dimension reduction
library(reticulate)
library(ggplot2)
library(lhs)
mogp_emulator <- import("mogp_emulator")
#obtain data
data = read.csv("~/My_Files/Covid/wards_by_day_100.csv", header = TRUE)
#tidy up the data
data_frame <- as.matrix(data)
X <- data_frame[,2:6]
y <- data_frame[,7:ncol(data_frame)]
X_valid <- X[126:200,]
y_valid <- y[126:200,]
X <- X[1:125,]
y <- y[1:125,]
#now convert data into quantiles
quantile_df <- data.frame(X = X, y = y) #create data frame
#quantile_df <-  quantile_df %>% group_by_at(vars(names(quantile_df)[1:(length(X[1,]))])) %>% summarise("0.025" = quantile(y, 0.025), "0.25" = quantile(y, 0.25), "0.5" = quantile(y, 0.5), "0.75" = quantile(y, 0.75), "0.975" = quantile(y, 0.975))
quantile_df <-  quantile_df %>% group_by_at(vars(names(quantile_df)[1:(length(X[1,]))]))
quantile_df
quantile_df %>% summarise_each(list(~quantile(., 0.025, na.rm=T),~quantile(., .25, na.rm = T), ~quantile(., .5, na.rm = T), ~quantile(., .75, na.rm = T), ~quantile(., .975, na.rm = T)))
quantile_df
expand.grid(X, c(0.025, 0.25, 0.5, 0.75, 0.975))
quantiles <- c(0.025, 0.25, 0.5, 0.75, 0.975)
cbind(X[rep(1:nrow(X), length(quantiles)), ], rep(quantiles, each = nrow(X)))
for (xq in XQ){
print(xq)
}
X_q = cbind(X[rep(1:nrow(X), length(quantiles)), ], rep(quantiles, each = nrow(X)))
#obtain y:
for (xq in X_q){
print(xq)
}
X_q
nrow(X)
nrow(X_q)
unique(X)
X_q = cbind(unique(X)[rep(1:nrow(unique(X)), length(quantiles)), ], rep(quantiles, each = nrow(unqiue(X))))
X_q = cbind(unique(X)[rep(1:nrow(unique(X)), length(quantiles)), ], rep(quantiles, each = nrow(unique(X))))
X_q
y
ncol(y)
X_q[1,]
X_q[1,1:(ncol(X_q)-1)]
X == X_q[1,1:(ncol(X_q)-1)]
X in X_q[1,1:(ncol(X_q)-1)]
X %in% X_q[1,1:(ncol(X_q)-1)]
X
X_q[1,1:(ncol(X_q)-1)] %in% X
X_q[1,1:(ncol(X_q)-1)] %in% t(X)
t(X_q[1,1:(ncol(X_q)-1)]) %in% X
X %in% X_q[1,1:(ncol(X_q)-1)]
X[X %in% X_q[1,1:(ncol(X_q)-1)]]
X[X %in% X_q[1,1:(ncol(X_q)-1)],]
all(X %in% X_q[1,1:(ncol(X_q)-1)])
which(apply(X, 1, function(x) all.equal(x[1:3], X_q[1,])) == "TRUE")
which(apply(X_q[1,1:(ncol(X_q)-1)], 1, function(x) all.equal(x[1:3], X[1,])) == "TRUE")
which(apply(X, 1, function(x) all.equal(x, X_q[1,1:(ncol(X_q)-1)])) == "TRUE")
which(apply(X, 1, function(x) all.equal(x, X_q[4,1:(ncol(X_q)-1)])) == "TRUE")
index = which(apply(X, 1, function(x) all.equal(x, X_q[row,1:(ncol(X_q)-1)])) == "TRUE") #which rows are relevant
row = 1
index = which(apply(X, 1, function(x) all.equal(x, X_q[row,1:(ncol(X_q)-1)])) == "TRUE") #which rows are relevant
index
y[index,]
apply(y[index,], 2, quantile, 0.025)
X_q[row, ncol(X_q)]
index = which(apply(X, 1, function(x) all.equal(x, X_q[row,1:(ncol(X_q)-1)])) == "TRUE") #which rows are relevant
apply(y[index,], 2, quantile, X_q[row, ncol(X_q)])
y_q[row, ] <- apply(y[index,], 2, quantile, X_q[row, ncol(X_q)]) #get necesarry quantile
y_q <- matrix(NA, nrow = nrow(X_q), ncol = ncol(y))
y_q[row, ] <- apply(y[index,], 2, quantile, X_q[row, ncol(X_q)]) #get necesarry quantile
y_q <- matrix(NA, nrow = nrow(X_q), ncol = ncol(y))
for (row in nrow(X_q)){ #for each X
index = which(apply(X, 1, function(x) all.equal(x, X_q[row,1:(ncol(X_q)-1)])) == "TRUE") #which rows are relevant
y_q[row, ] <- apply(y[index,], 2, quantile, X_q[row, ncol(X_q)]) #get necesarry quantile
}
y_q
y_q[1:5, 1:10]
is.na(y_q)
sum(is.na(y_q))
length(y_q)
nrow(y_q)
y_q[row,]
y_q[row,]
row
y_q[1,]
y_q[2,]
y_q[3,]
y_q[125,]
y_q <- matrix(NA, nrow = nrow(X_q), ncol = ncol(y))
for (row in 1:nrow(X_q)){ #for each X
index = which(apply(X, 1, function(x) all.equal(x, X_q[row,1:(ncol(X_q)-1)])) == "TRUE") #which rows are relevant
y_q[row, ] <- apply(y[index,], 2, quantile, X_q[row, ncol(X_q)]) #get necesarry quantile
}
y_q <- matrix(NA, nrow = nrow(X_q), ncol = ncol(y))
for (row in 1:nrow(X_q)){ #for each X
index = which(apply(X, 1, function(x) all.equal(x, X_q[row,1:(ncol(X_q)-1)])) == "TRUE") #which rows are relevant
y_q[row, ] <- apply(y[index,], 2, quantile, X_q[row, ncol(X_q)]) #get necesarry quantile
print(row)
}
y_q
y_q[1,]
X_q
X_q[1,]
X_q[26,]
y_q[1,]
y_q[26,]
#So the first step is to edit our data again...
#The data is bound by zero, so we sqrt it, this ensures predictions will also follow this constraint
y_q_sqrt <- sqrt(y_q)
#We then also have too many output dimensions, so we reduce this via PCA
y_pr <- prcomp(y_q_sqrt, rank = 20)
summary(y_pr) #only first 2 matter
n_out <- 5 #how many PCs matter?
n_dropped = 15 #how many lost?
#get our "outputs"
y_out <- y_pr$x[,1:n_out]
#Fit GPs
#(I have a bug with my mogp installation that I cant fix where multiple output doesnt work, so I fit independent GPs manually)
QK_emuls <- list()
for (i in 1:n_out){#for each output dim
#fit emul
gp <- mogp_emulator$GaussianProcess(inputs, outputs, nugget = "fit")
gp <- mogp_emulator$fit_GP_MAP(gp)
#save results
QK_emuls <- c(QK_emuls, gp)
}
#This script does QK-PCA where the quantiles are calculated before dimension reduction
library(reticulate)
library(ggplot2)
library(lhs)
mogp_emulator <- import("mogp_emulator")
#Fit GPs
#(I have a bug with my mogp installation that I cant fix where multiple output doesnt work, so I fit independent GPs manually)
QK_emuls <- list()
for (i in 1:n_out){#for each output dim
#fit emul
gp <- mogp_emulator$GaussianProcess(inputs, outputs, nugget = "fit")
gp <- mogp_emulator$fit_GP_MAP(gp)
#save results
QK_emuls <- c(QK_emuls, gp)
}
mogp_emulator <- import("mogp_emulator")
#Fit GPs
#(I have a bug with my mogp installation that I cant fix where multiple output doesnt work, so I fit independent GPs manually)
QK_emuls <- list()
for (i in 1:n_out){#for each output dim
#fit emul
gp <- mogp_emulator$GaussianProcess(inputs, outputs, nugget = "fit")
gp <- mogp_emulator$fit_GP_MAP(gp)
#save results
QK_emuls <- c(QK_emuls, gp)
}
#Fit GPs
#(I have a bug with my mogp installation that I cant fix where multiple output doesnt work, so I fit independent GPs manually)
QK_emuls <- list()
for (i in 1:n_out){#for each output dim
#fit emul
gp <- mogp_emulator$GaussianProcess(X_q, y_out[,i], nugget = "fit")
gp <- mogp_emulator$fit_GP_MAP(gp)
#save results
QK_emuls <- c(QK_emuls, gp)
}
QK_emuls
#combine with 5 different quantiles we shall predict for (doesnt have to be the same as we fit with)
quantiles_pred <- c(0.025, 0.25, 0.5, 0.75, 0.975)
X_pred_q <- cbind(X_pred[rep(1:nrow(X_pred), length(quantiles_pred)), ], rep(quantiles_pred, each = nrow(X_pred)))
X_pred <- randomLHS(100,5) * 2 -1
X_pred[,5] <-  0.5
X_pred[,1:3] <- 0.5
X_pred_q <- cbind(X_pred[rep(1:nrow(X_pred), length(quantiles_pred)), ], rep(quantiles_pred, each = nrow(X_pred)))
X_pred_q
QK_emuls[[1]][1]
QK_emuls[[1]]
#predict using each GP
predicts <- list()
for (i in 1:n_out){#for each output dim
predict <- QK_emuls[[i]]$predict(X_pred_q)
predicts <- c(predicts, predict) #save results
}
predicts
predicts[[1]]
predicts[[1]]$mean
trans_pred = cbind(QKpred[i,], QKpred[i,], QKpred[i,], QKpred[i,], QKpred[i,], matrix(0, ncol = n_dropped, nrow = nrow(X_pred)) )
trans_pred = cbind(predicts[i,], predicts[i,], predicts[i,], predicts[i,], predicts[i,], matrix(0, ncol = n_dropped, nrow = nrow(X_pred)) )
setwd("~/My_Files/Covid/uq4covid.github.io/vignettes")
knitr::opts_chunk$set(echo = TRUE)
data = read.csv("~/data/QuantileKriging_experiment/wards_by_day_100.csv", header = TRUE)
getwd()
read.csv("/data/QuantileKriging_experiment/wards_by_day_100.csv", header = TRUE)
setwd("~/My_Files/Covid/uq4covid.github.io/vignettes/data/QuantileKriging_experiment")
data = read.csv("/data/QuantileKriging_experiment/wards_by_day_100.csv", header = TRUE)
read.csv("wards_by_day_100.csv")
read.csv("wards_by_day_100.csv", header = TRUE)
setwd("~/My_Files/Covid/uq4covid.github.io/vignettes")
data = read.csv("data/QuantileKriging_experiment/wards_by_day_100.csv", header = TRUE)
data = read.csv("~/data/QuantileKriging_experiment/wards_by_day_100.csv", header = TRUE)
